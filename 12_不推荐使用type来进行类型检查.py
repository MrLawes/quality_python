"""
作为动态性的强类型脚本语言，Python中的变量在定义的时候并不会指明具体类型，Python解释器会在运行时自动进行类型检查并根据需要进行隐式类型转换。按照Python的理念，为了充分利用其动态性的特征是不推荐进行类型检查的。如下面的函数add()，在无需对参数进行任何约束的情况下便可以轻松地实现字符串的连接、数字的加法、列表的合并等多种功能，甚至处理复数都非常灵活。解释器能够根据变量类型的不同调用合适的内部方法进行处理，而当a、b类型不同而两者之间又不能进行隐式类型转换时便抛出TypeError异常。
"""


def add(a, b):
    return a + b


"""
不刻意进行类型检查，而是在出错的情况下通过抛出异常来进行处理，这是较为常见的方式。但实际应用中为了提高程序的健壮性，仍然会面临需要进行类型检查的情景。那么使用什么方法呢？很容易想到，使用type()。内建函数type(object)用于返回当前对象的类型，如type(1)返回<type 'int'>。因此可以通过与Python自带模块types中所定义的名称进行比较，根据其返回值确定变量类型是否符合要求。
"""


class UserInt(int):
    def __init__(self, val=0):
        self._vala = int(val)


n = UserInt(1)
print(type(n))

"""
这说明type()函数认为n并不是int类型，但UserInt继承自int，显然这种判断不合理。由此可见基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。
"""

"""
因此对于内建的基本类型来说，也许使用type()进行类型检查问题不大，但在某些特殊场合type()方法并不可靠。那么究竟应怎样来约束用户的输入类型从而使之与我们期望的类型一致呢？
答案是：如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，如list(listing)、str(name)等，否则可以使用isinstance()函数来检测
"""
