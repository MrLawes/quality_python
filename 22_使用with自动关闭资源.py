"""
来做个简单的试验，观察一下发生的现象。在Python解释器中输入下面两行代码，会有什么情况发生呢？

f = open('test.txt', 'w')
f.write('test')


答案是：在解释器所在的目录下生成了一个文件test.txt，并且在里面写入了字符串test，对吗？事实真相是：的确生成了一个文件，但其内容为空，并没有写入任何字符串。这个一个简单得不能再简单的问题，相信不用多说你已经知道症结所在了。对文件操作完成后应该立即关闭它们，这是一个常识。我们都知道需要这么做，在很多编程语言中都会强调这个问题，因为打开的文件不仅会占用系统资源，而且可能影响其他程序或者进程的操作，甚至会导致用户期望与实际操作结果不一致。但实际应用中真相往往是：即使我们心中记得这个原则，但仍然可能会忘记关闭它。为什么？因为编程人员会把更多的精力和注意力放在对具体文件内容的操作和处理上；或者设计的正常流程是处理完毕关闭文件，但结果程序执行过程中发生了异常导致关闭文件的代码没有被执行到。也许你会说，还有try..finally块。对！这是一种比较古老的方法，但Python提供了一种更为简单的解决方案：with语句。with语句的语法为：

"""

"""
with语句的使用非常简单，本节开头的例子改用with语句能够保证当写操作执行完毕后自动关闭文件。

with open('test.txt', 'w') as f:
    f.write('test')

"""

"""

with语句可以在代码块执行完毕后还原进入该代码块时的现场。包含有with语句的代码块的执行过程如下：
1）计算表达式的值，返回一个上下文管理器对象。
2）加载上下文管理器对象的__exit__()方法以备后用。
3）调用上下文管理器对象的__enter__()方法。
4）如果with语句中设置了目标对象，则将__enter__()方法的返回值赋值给目标对象。
5）执行with中的代码块。
6）如果步骤5中代码正常结束，调用上下文管理器对象的_exit__()方法，其返回值直接忽略。
7）如果步骤5中代码执行过程中发生异常，调用上下文管理器对象的_exit__()方法，并将异常类型、值及traceback信息作为参数传递给__exit__()方法。
如果_exit__()返回值为false，则异常会被重新抛出；如果其返回值为true，异常被挂起，程序继续执行。

"""

